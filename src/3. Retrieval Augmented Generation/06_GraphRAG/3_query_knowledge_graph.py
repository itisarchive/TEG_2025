"""
GraphRAG Query System for CV Knowledge Graph
=============================================

Demonstrates GraphRAG capabilities by querying the knowledge graph
built from PDF CVs using natural language queries.

Shows advantages of structured Cypher queries (generated by an LLM)
over traditional vector-similarity RAG.

Prerequisites:
    - Azure OpenAI credentials in environment / .env
    - Neo4j running with a populated knowledge graph
      (see 0_setup.py, 2_data_to_knowledge_graph.py)
"""

import logging
import textwrap
from dataclasses import dataclass

from dotenv import load_dotenv
from langchain_core.prompts.prompt import PromptTemplate
from langchain_neo4j import GraphCypherQAChain, Neo4jGraph
from langchain_openai import AzureChatOpenAI
from neo4j.exceptions import CypherSyntaxError, GqlError

load_dotenv(override=True)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

CYPHER_GENERATION_TEMPLATE = textwrap.dedent("""\
    Task: Generate Cypher statement to query a graph database.
    Instructions:
    Use only the provided relationship types and properties in the schema.
    Do not use any other relationship types or properties that are not provided.
    For skill matching, always use case-insensitive comparison using toLower() function.
    For count queries, ensure you return meaningful column names.

    Schema:
    {schema}

    Note: Do not include any explanations or apologies in your responses.
    Do not respond to any questions that might ask anything else than for you to construct a Cypher statement.
    Do not include any text except the generated Cypher statement.

    Examples: Here are a few examples of generated Cypher statements for particular questions:

    # How many Python programmers do we have?
    MATCH (p:Person)-[:HAS_SKILL]->(s:Skill)
    WHERE toLower(s.id) = toLower("Python")
    RETURN count(p) AS pythonProgrammers

    # Who has React skills?
    MATCH (p:Person)-[:HAS_SKILL]->(s:Skill)
    WHERE toLower(s.id) = toLower("React")
    RETURN p.id AS name

    # Find people with both Python and Django skills
    MATCH (p:Person)-[:HAS_SKILL]->(s1:Skill), (p)-[:HAS_SKILL]->(s2:Skill)
    WHERE toLower(s1.id) = toLower("Python") AND toLower(s2.id) = toLower("Django")
    RETURN p.id AS name

    The question is:
    {question}""")

CYPHER_ANSWER_TEMPLATE = textwrap.dedent("""\
    You are an assistant that helps to form nice and human understandable answers.
    The information part contains the result(s) of a Cypher query that was executed against a knowledge graph.
    Information is provided as a list of records from the graph database.

    Guidelines:
    - If the information contains count results or numbers, state the exact count clearly.
    - For count queries that return 0, say "There are 0 [items]" - this is a valid result, not missing information.
    - If the information is empty or null, then say you don't know the answer.
    - Use the provided information to construct a helpful answer.
    - Be specific and mention actual names, numbers, or details from the information.

    Information:
    {context}

    Question: {question}
    Helpful Answer:""")

EXAMPLE_QUERY_CATEGORIES: dict[str, list[str]] = {
    "Basic Information": [
        "How many people are in the knowledge graph?",
        "What companies appear in the CVs?",
        "List all the skills mentioned in the CVs.",
        "What certifications do people have?",
        "Which universities appear in the CVs?",
        "What job titles are mentioned?",
        "Show me all the locations where people are based.",
    ],
    "Skill-based Queries": [
        "Who has Python programming skills?",
        "Find all people with React experience.",
        "Who has both Docker and Kubernetes skills?",
        "List people with JavaScript skills.",
        "Find people who know both Python and Django.",
        "Who has cloud computing skills like AWS?",
        "What programming languages are most common?",
        "Find people with machine learning expertise.",
    ],
    "Company Experience": [
        "Who worked at Google?",
        "Find people who worked at Microsoft.",
        "What companies have the most former employees in our database?",
        "Who worked at technology companies?",
        "Find people with startup experience.",
        "List all companies mentioned in the CVs.",
        "Who has experience at Fortune 500 companies?",
    ],
    "Education Background": [
        "Who studied at Stanford University?",
        "Find people with computer science education.",
        "What universities are most common in our database?",
        "Who has a Master's degree?",
        "Find people who studied at Ivy League schools.",
        "What are the most common degree types?",
        "Who has a PhD?",
    ],
    "Location and Geography": [
        "Who is located in San Francisco?",
        "Find people in California.",
        "What cities have the most people?",
        "Who is located in New York?",
        "Find people in the United States.",
        "Show all locations in our database.",
        "Find people willing to relocate.",
    ],
    "Professional Experience": [
        "Who has the most years of experience?",
        "Find senior-level professionals.",
        "Who worked in software development roles?",
        "Find people with leadership experience.",
        "Who has experience in data science?",
        "List all job titles mentioned.",
        "Find people with consulting experience.",
    ],
    "Multi-hop Reasoning": [
        "Find people who worked at the same companies.",
        "Who went to the same university and has similar skills?",
        "Find people who have complementary skills for a team.",
        "What skills are commonly paired together?",
        "Find potential colleagues based on shared experience.",
        "Who studied at top universities and has industry experience?",
        "Find people with both technical and business skills.",
    ],
    "Certification Analysis": [
        "Who has AWS certifications?",
        "Find all Google Cloud certified people.",
        "What are the most common certifications?",
        "Who has multiple certifications?",
        "Find people with security certifications.",
        "List all certification providers.",
        "Who has recent certifications?",
    ],
}

MENU_CATEGORY_MAP: dict[str, str] = {
    "1": "Basic Information",
    "2": "Skill-based Queries",
    "3": "Company Experience",
    "4": "Education Background",
    "5": "Professional Experience",
    "6": "Multi-hop Reasoning",
    "7": "Certification Analysis",
}


@dataclass(frozen=True)
class GraphQueryResult:
    """Structured result of a natural-language query executed against the knowledge graph."""

    question: str
    answer: str
    generated_cypher: str
    is_successful: bool


def print_section_header(title: str) -> None:
    separator = "=" * 60
    print(f"\n{separator}\n{title}\n{separator}")


def print_query_result(query_result: GraphQueryResult) -> None:
    if query_result.is_successful:
        print(
            f"üìä Generated Cypher: {query_result.generated_cypher}\n"
            f"üí° Answer: {query_result.answer}"
        )
    else:
        print(f"‚ùå Error: {query_result.answer}")


class CVGraphRAGSystem:
    """
    GraphRAG system for natural-language queries on a CV knowledge graph.

    Connects to a Neo4j database, builds a LangChain GraphCypherQAChain
    (backed by Azure OpenAI), and translates plain-English questions into
    Cypher queries whose results are then summarized in natural language.
    """

    def __init__(self) -> None:
        self.neo4j_graph = self._connect_to_neo4j()
        self.cypher_qa_chain = self._build_cypher_qa_chain(self.neo4j_graph)

    @staticmethod
    def _connect_to_neo4j() -> Neo4jGraph:
        try:
            neo4j_graph = Neo4jGraph(
                url="bolt://localhost:7687",
                username="neo4j",
                password="password123",
            )
            neo4j_graph.refresh_schema()
            logger.info("‚úì Connected to Neo4j successfully")
            logger.info("‚úì Graph schema refreshed")
            return neo4j_graph
        except (GqlError, ConnectionError, OSError) as connection_error:
            logger.error("Failed to connect to Neo4j: %s", connection_error)
            print(textwrap.dedent("""\
                ‚ùå Could not connect to Neo4j. Make sure it's running:
                   ./start_session.sh"""))
            raise

    @staticmethod
    def _build_cypher_qa_chain(neo4j_graph: Neo4jGraph) -> GraphCypherQAChain:
        azure_llm = AzureChatOpenAI(model="gpt-4.1", temperature=0)

        cypher_generation_prompt = PromptTemplate(
            input_variables=["schema", "question"],
            template=CYPHER_GENERATION_TEMPLATE,
        )
        cypher_answer_prompt = PromptTemplate(
            input_variables=["context", "question"],
            template=CYPHER_ANSWER_TEMPLATE,
        )

        cypher_qa_chain = GraphCypherQAChain.from_llm(
            llm=azure_llm,
            graph=neo4j_graph,
            verbose=True,
            cypher_prompt=cypher_generation_prompt,
            qa_prompt=cypher_answer_prompt,
            return_intermediate_steps=True,
            allow_dangerous_requests=True,
        )
        logger.info("‚úì GraphCypher QA chain initialized with custom prompts")
        return cypher_qa_chain

    def execute_natural_language_query(self, question: str) -> GraphQueryResult:
        """
        Translate a natural-language question into a Cypher query, run it
        against Neo4j, and return the answer wrapped in a GraphQueryResult.
        """
        try:
            logger.info("Executing query: %s", question)
            chain_output = self.cypher_qa_chain.invoke({"query": question})

            intermediate_steps = chain_output.get("intermediate_steps", [{}])
            generated_cypher = (
                intermediate_steps[0].get("query", "") if intermediate_steps else ""
            )

            logger.info("‚úì Query executed successfully")
            return GraphQueryResult(
                question=question,
                answer=chain_output.get("result", "No answer generated"),
                generated_cypher=generated_cypher,
                is_successful=True,
            )
        except (GqlError, CypherSyntaxError, ValueError, RuntimeError) as query_error:
            logger.error("Query failed: %s", query_error)
            return GraphQueryResult(
                question=question,
                answer=f"Error: {query_error}",
                generated_cypher="",
                is_successful=False,
            )

    def run_example_queries_for_categories(
            self, category_name: str | None = None
    ) -> list[GraphQueryResult]:
        """Run pre-defined example queries for one or all categories to demonstrate GraphRAG."""
        collected_results: list[GraphQueryResult] = []
        categories_to_run = (
            [category_name] if category_name else list(EXAMPLE_QUERY_CATEGORIES)
        )

        for current_category in categories_to_run:
            if current_category not in EXAMPLE_QUERY_CATEGORIES:
                logger.warning("Category '%s' not found", current_category)
                continue

            print_section_header(f"Category: {current_category}")

            for example_question in EXAMPLE_QUERY_CATEGORIES[current_category]:
                print(f"\nüîç Query: {example_question}\n"
                      f"{'-' * 40}")

                query_result = self.execute_natural_language_query(example_question)
                collected_results.append(query_result)
                print_query_result(query_result)
                print()

        return collected_results

    def print_custom_query_result(self, question: str) -> None:
        """Execute a single custom question and print the result."""
        print(f"\nüîç Custom Query: {question}\n"
              f"{'-' * 50}")
        print_query_result(self.execute_natural_language_query(question))

    def validate_graph_content(self) -> bool:
        """
        Validate that the knowledge graph has enough content for meaningful queries.

        Checks node counts, relationship counts, and prints a summary.
        Returns True when the graph contains at least one Person node.
        """
        available_node_labels = self._fetch_node_labels_safe()

        validation_cypher_pairs: list[tuple[str, str]] = [
            ("Total nodes", "MATCH (n) RETURN count(n) as count"),
            ("Total relationships", "MATCH ()-[r]->() RETURN count(r) as count"),
        ]

        expected_node_labels = [
            "Person", "Company", "Skill", "University",
            "Certification", "Project", "Location",
        ]
        for node_label in expected_node_labels:
            if node_label in available_node_labels:
                validation_cypher_pairs.append(
                    (f"{node_label} count", f"MATCH (n:{node_label}) RETURN count(n) as count")
                )

        print("\nüìä Graph Validation\n"
              "-" * 30)

        total_node_count = 0
        person_node_count = 0

        for metric_description, cypher_query in validation_cypher_pairs:
            try:
                cypher_result = self.neo4j_graph.query(cypher_query)
                node_count = cypher_result[0]["count"] if cypher_result else 0
                print(f"{metric_description}: {node_count:,}")

                if metric_description == "Total nodes":
                    total_node_count = node_count
                elif metric_description == "Person count":
                    person_node_count = node_count
            except GqlError as cypher_error:
                print(f"{metric_description}: Error - {cypher_error}")

        self._print_relationship_summary()

        if available_node_labels:
            print(f"\nüè∑Ô∏è  Available Node Types: {', '.join(available_node_labels)}")

        available_relationship_types = self._fetch_relationship_types_safe()
        if available_relationship_types:
            print(f"üîó Available Relationships: {', '.join(available_relationship_types)}")

        if person_node_count == 0:
            print(textwrap.dedent("""\

                ‚ö†Ô∏è  Warning: No Person nodes found in the graph!
                Please run 2_data_to_knowledge_graph.py first to populate the graph.
                Or check: uv run python 0_setup.py --check"""))
            return False

        if total_node_count < 10:
            print(f"\n‚ö†Ô∏è  Warning: Only {total_node_count} nodes found. Consider generating more data.")

        print(f"\n‚úÖ Graph validation successful: {person_node_count} people, {total_node_count} total nodes")
        return True

    def show_graph_schema(self) -> None:
        """Display the current graph schema with node/relationship counts and sample data."""
        print("\nüìã Graph Schema\n"
              "-" * 30)

        try:
            node_labels = self._fetch_node_labels()
            self._print_node_type_counts(node_labels)

            relationship_types = self._fetch_relationship_types()
            self._print_relationship_type_counts(relationship_types)

            print("\nüìä Sample Data:")
            self._print_sample_people()
            self._print_sample_skills()

        except GqlError as schema_error:
            print(f"Error displaying schema: {schema_error}")
            print("\nFallback schema:")
            try:
                print(self.neo4j_graph.schema)
            except GqlError:
                print("Unable to retrieve schema")

    def _fetch_node_labels_safe(self) -> list[str]:
        try:
            return self._fetch_node_labels()
        except GqlError:
            return []

    def _fetch_node_labels(self) -> list[str]:
        try:
            labels_result = self.neo4j_graph.query(
                "CALL db.labels() YIELD label RETURN label ORDER BY label"
            )
            return [row["label"] for row in labels_result if row["label"] != "__Entity__"]
        except GqlError:
            fallback_result = self.neo4j_graph.query(
                "MATCH (n) RETURN DISTINCT labels(n) as labels ORDER BY labels[0]"
            )
            all_labels: list[str] = []
            for row in fallback_result:
                label_list = row["labels"]
                if label_list:
                    all_labels.extend(
                        single_label for single_label in label_list if single_label != "__Entity__"
                    )
            return sorted(set(all_labels))

    def _fetch_relationship_types_safe(self) -> list[str]:
        try:
            return self._fetch_relationship_types()
        except GqlError:
            return []

    def _fetch_relationship_types(self) -> list[str]:
        try:
            relationship_result = self.neo4j_graph.query(
                "CALL db.relationshipTypes() YIELD relationshipType "
                "RETURN relationshipType ORDER BY relationshipType"
            )
            return [row["relationshipType"] for row in relationship_result]
        except GqlError:
            fallback_result = self.neo4j_graph.query(
                "MATCH ()-[r]->() RETURN DISTINCT type(r) as rel_type ORDER BY rel_type"
            )
            return [row["rel_type"] for row in fallback_result]

    def _print_node_type_counts(self, node_labels: list[str]) -> None:
        print("üè∑Ô∏è  Node Types:")
        if not node_labels:
            print("   No node types found")
            return

        for label in node_labels:
            try:
                count_result = self.neo4j_graph.query(f"MATCH (n:{label}) RETURN count(n) as count")
                label_count = count_result[0]["count"] if count_result else 0
                print(f"   ‚Ä¢ {label} ({label_count:,} nodes)")
            except GqlError:
                print(f"   ‚Ä¢ {label}")

    def _print_relationship_type_counts(self, relationship_types: list[str]) -> None:
        print("\nüîó Relationship Types:")
        if not relationship_types:
            print("   No relationships found")
            return

        for relationship_type in relationship_types:
            try:
                count_result = self.neo4j_graph.query(
                    f"MATCH ()-[r:{relationship_type}]->() RETURN count(r) as count"
                )
                relationship_count = count_result[0]["count"] if count_result else 0
                print(f"   ‚Ä¢ {relationship_type} ({relationship_count:,} relationships)")
            except GqlError:
                print(f"   ‚Ä¢ {relationship_type}")

    def _print_relationship_summary(self) -> None:
        print("\nüîó Key Relationships:")

        relationship_cypher_pairs = [
            ("Person-Skill connections", "MATCH (p:Person)-[r]->(s:Skill) RETURN count(*) as count"),
            ("Person-Company connections", "MATCH (p:Person)-[r]->(c:Company) RETURN count(*) as count"),
            ("Person-University connections", "MATCH (p:Person)-[r]->(u:University) RETURN count(*) as count"),
            ("Person-Location connections", "MATCH (p:Person)-[r]->(l:Location) RETURN count(*) as count"),
            (
                "Person-Certification connections",
                "MATCH (p:Person)-[r]->(cert:Certification) RETURN count(*) as count",
            ),
        ]

        for relationship_description, cypher_query in relationship_cypher_pairs:
            try:
                cypher_result = self.neo4j_graph.query(cypher_query)
                relationship_count = cypher_result[0]["count"] if cypher_result else 0
                if relationship_count > 0:
                    print(f"{relationship_description}: {relationship_count:,}")
            except GqlError:
                pass

    def _print_sample_people(self) -> None:
        people_cypher_variants = [
            ("MATCH (p:Person) RETURN p.id as name LIMIT 3", "id"),
            ("MATCH (p:Person) RETURN p.name as name LIMIT 3", "name"),
        ]

        for cypher_query, property_name in people_cypher_variants:
            try:
                people_rows = self.neo4j_graph.query(cypher_query)
                if people_rows and people_rows[0].get("name"):
                    print(f"   People (via {property_name}):")
                    for person_row in people_rows[:3]:
                        if person_row.get("name"):
                            print(f"     - {person_row['name']}")
                    return
            except GqlError:
                continue

        try:
            raw_people_rows = self.neo4j_graph.query("MATCH (p:Person) RETURN p LIMIT 3")
            if raw_people_rows:
                print("   People (raw properties):")
                for person_row in raw_people_rows:
                    node_properties = person_row.get("p", {})
                    if isinstance(node_properties, dict) and node_properties:
                        first_property_key = next(iter(node_properties))
                        print(f"     - {node_properties[first_property_key]} ({first_property_key})")
        except GqlError:
            pass

    def _print_sample_skills(self) -> None:
        skills_cypher_variants = [
            ("MATCH (s:Skill) RETURN s.id as skill LIMIT 5", "id"),
            ("MATCH (s:Skill) RETURN s.name as skill LIMIT 5", "name"),
        ]

        for cypher_query, property_name in skills_cypher_variants:
            try:
                skill_rows = self.neo4j_graph.query(cypher_query)
                if skill_rows and skill_rows[0].get("skill"):
                    print(f"   Skills (via {property_name}):")
                    for single_skill_row in skill_rows[:5]:
                        if single_skill_row.get("skill"):
                            print(f"     - {single_skill_row['skill']}")
                    return
            except GqlError:
                continue

    def run_interactive_mode(self) -> None:
        """Start interactive query mode ‚Äî type natural-language questions or 'quit' to exit."""
        print(textwrap.dedent("""\

            üéØ Interactive GraphRAG Query Mode
            Type your questions or 'quit' to exit
            ----------------------------------------"""))

        while True:
            try:
                user_question = input("\n‚ùì Your question: ").strip()

                if user_question.lower() in ("quit", "exit", "q"):
                    print("üëã Goodbye!")
                    break

                if not user_question:
                    continue

                self.print_custom_query_result(question=user_question)

            except KeyboardInterrupt:
                print("\nüëã Goodbye!")
                break
            except (GqlError, RuntimeError) as interactive_error:
                print(f"‚ùå Error: {interactive_error}")


def main() -> None:
    """Demonstrate GraphRAG capabilities on a CV-only knowledge graph."""
    print(textwrap.dedent("""\
        CV Knowledge Graph - GraphRAG Query System
        Natural Language Queries for CV Data
        =================================================="""))

    try:
        graph_rag_system = CVGraphRAGSystem()

        if not graph_rag_system.validate_graph_content():
            return

        graph_rag_system.show_graph_schema()

        while True:
            print("\nüéØ GraphRAG Demo Options:")
            for menu_key, menu_category_name in MENU_CATEGORY_MAP.items():
                print(f"{menu_key}. {menu_category_name} queries")
            print("8. Run ALL example queries")
            print("9. Interactive query mode")
            print("0. Exit")

            user_choice = input("\nSelect option (0-9): ").strip()

            if user_choice in MENU_CATEGORY_MAP:
                graph_rag_system.run_example_queries_for_categories(
                    category_name=MENU_CATEGORY_MAP[user_choice]
                )
            elif user_choice == "8":
                graph_rag_system.run_example_queries_for_categories()
            elif user_choice == "9":
                graph_rag_system.run_interactive_mode()
            elif user_choice == "0":
                print("üëã Goodbye!")
                break
            else:
                print("‚ùå Invalid option. Please select 0-9.")

    except (GqlError, ConnectionError) as system_error:
        logger.error("System error: %s", system_error)
        print(f"‚ùå Error: {system_error}")
    except RuntimeError as runtime_error:
        logger.error("System error: %s", runtime_error)
        print(f"‚ùå Error: {runtime_error}")


if __name__ == "__main__":
    main()
